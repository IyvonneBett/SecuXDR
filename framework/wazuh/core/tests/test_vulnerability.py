#!/usr/bin/env python
# Copyright (C) 2015, Wazuh Inc.
# Created by Wazuh, Inc. <info@wazuh.com>.
# This program is a free software; you can redistribute it and/or modify it under the terms of GPLv2

import json
import os
import sys
from datetime import datetime
from unittest.mock import ANY, patch, MagicMock

with patch('wazuh.core.common.wazuh_uid'):
    with patch('wazuh.core.common.wazuh_gid'):
        sys.modules['wazuh.rbac.orm'] = MagicMock()
        import wazuh.rbac.decorators
        from wazuh.tests.util import RBAC_bypasser

        del sys.modules['wazuh.rbac.orm']
        wazuh.rbac.decorators.expose_resources = RBAC_bypasser

        from api import util
        from wazuh.core import vulnerability
        from wazuh.core.tests import test_agent

test_data_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'data')
test_data = test_agent.InitAgent()
test_data_cve = test_agent.InitAgent(data_path=os.path.join(test_data_path, 'test_vulnerability'),
                                     db_name='schema_cve_test.sql')


def send_msg_to_wdb(msg, raw=False):
    query = msg[msg.find('sql') + len('sql '):]
    result = test_data.cur.execute(query).fetchall() if msg.startswith('global') else test_data_cve.cur.execute(
        query).fetchall()
    result = list(map(util.remove_nones_to_dict, map(dict, result)))
    return ['ok', json.dumps(result)] if raw else result


@patch("wazuh.core.vulnerability.WazuhDBBackend")
@patch("wazuh.core.agent.WazuhDBQuery.__init__")
@patch('wazuh.core.wdb.WazuhDBConnection._send')
@patch('wazuh.core.agent.Agent.get_basic_information')
@patch('socket.socket.connect')
def test_WazuhDBQueryVulnerability__init__(mock_conn, mock_info, mock_send, mock_wazuhDBQuery, mock_backend):
    """Test if method __init__ of WazuhDBQueryVulnerability calls WazuhDBQuery with expected params"""
    vulnerability.WazuhDBQueryVulnerability(agent_id='001', offset=500, limit=500, query='version>3.9.81')
    mock_backend.assert_called_once_with('001')
    mock_wazuhDBQuery.assert_called_once_with(
        ANY, offset=500, limit=500, table='vuln_cves', sort=None, search=None, select=None,
        fields={'name': 'name', 'version': 'version', 'architecture': 'architecture', 'cve': 'cve', 'status': 'status',
                'type': 'type', 'detection_time': 'detection_time', 'severity': 'severity',
                'cvss2_score': 'cvss2_score', 'cvss3_score': 'cvss3_score',
                'external_references': 'external_references', 'condition': 'condition', 'title': 'title',
                'published': 'published', 'updated': 'updated'},
        filters={}, count=True, get_data=True, date_fields={'detection_time', 'last_partial_scan', 'last_full_scan'},
        min_select_fields=set(), distinct=False, default_sort_field='name', default_sort_order='ASC',
        query='version>3.9.81', backend=ANY
    )


@patch('wazuh.core.utils.path.exists', return_value=True)
@patch('wazuh.core.wdb.WazuhDBConnection._send', side_effect=send_msg_to_wdb)
@patch('socket.socket.connect')
def test_WazuhDBQueryVulnerability_format_data_into_dictionary(socket_mock, send_mock, exists_mock):
    """Check that WazuhDBQueryVulnerability's method _format_data_into_dictionary works properly."""
    with vulnerability.WazuhDBQueryVulnerability(agent_id='001', limit=1) as db_query:
        item = db_query.run()['items'][0]

    data = {
        'severity': 'Low', 'cvss3_score': 2.5, 'title': 'ASH-AIO before 2.0.0.3 allows an open redirect.', 'type': 'OS',
        'cve': 'CVE-2019-1020016', 'architecture': 'x86', 'updated': '2019-08-01', 'condition': 'Package unfixed',
        'published': '2019-07-29', 'status': 'OBSOLETE', 'detection_time': '1623656751', 'cvss2_score': 1.9,
        'name': 'Ash-aio', 'version': '2.0.0.0',
        'external_references': '["https://github.com/ASHTeam/ash-aio-2/security/advisories/GHSA-cg3m-qj5v-8g48"]'
    }

    assert all(item[field] == data[field] for field in item.keys() - {'external_references', 'detection_time'})
    assert item['external_references'] == json.loads(data['external_references'])
    assert item['detection_time'] == vulnerability.get_date_from_timestamp(int(data['detection_time']))
