#!/usr/bin/env python
# Copyright (C) 2015, Wazuh Inc.
# Created by Wazuh, Inc. <info@wazuh.com>.
# This program is free software; you can redistribute it and/or modify it under the terms of GPLv2
import json
import os
import sys
from json import dumps
from unittest.mock import MagicMock, patch

import pytest

from wazuh.core.results import AffectedItemsWazuhResult

sys.path.append(os.path.join(os.path.dirname(os.path.realpath(__file__)), '../..'))

with patch('wazuh.core.common.wazuh_uid'):
    with patch('wazuh.core.common.wazuh_gid'):
        sys.modules['wazuh.rbac.orm'] = MagicMock()
        import wazuh.rbac.decorators
        from wazuh.tests.util import RBAC_bypasser

        del sys.modules['wazuh.rbac.orm']
        wazuh.rbac.decorators.expose_resources = RBAC_bypasser

        from api.util import remove_nones_to_dict, parse_api_param
        from wazuh.vulnerability import get_agent_cve, get_inventory_summary, run_vulnerability_scan, \
            SCAN_ON_DEMAND_EXCEPTION
        from wazuh.core.tests.test_agent import InitAgent

test_data_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'data')
test_data = InitAgent(data_path=test_data_path)
test_data_cve = InitAgent(data_path=test_data_path, db_name='schema_cve_test.sql')


def send_msg_to_wdb(msg, raw=False):
    query = msg[msg.find('sql') + len('sql '):]
    result = test_data.cur.execute(query).fetchall() if msg.startswith('global') else test_data_cve.cur.execute(
        query).fetchall()
    result = list(map(remove_nones_to_dict, map(dict, result)))
    return ['ok', dumps(result)] if raw else result


@pytest.mark.parametrize('params, field_name, expected_items', [
    ({}, 'cve', ['CVE-2019-1020016', 'CVE-2019-1020014', 'CVE-2019-1020018', 'CVE-2019-1020019', 'CVE-2019-1020011']),
    ({'limit': 2}, 'cve', ['CVE-2019-1020016', 'CVE-2019-1020014']),
    ({'offset': 4, 'limit': 1}, 'cve', ['CVE-2019-1020011']),
    ({'sort': parse_api_param('+name', 'sort')}, 'name', ['Ash-aio', 'Credential Helpers', 'Discourse',
                                                          'Invenio-previewer', 'Smokedetector']),
    ({'sort': parse_api_param('-name', 'sort')}, 'name', ['Smokedetector', 'Invenio-previewer', 'Discourse',
                                                          'Credential Helpers', 'Ash-aio']),
    ({'sort': parse_api_param('+cve', 'sort')}, 'cve', ['CVE-2019-1020011', 'CVE-2019-1020014', 'CVE-2019-1020016',
                                                        'CVE-2019-1020018', 'CVE-2019-1020019']),
    ({'sort': parse_api_param('-cve', 'sort')}, 'cve', ['CVE-2019-1020019', 'CVE-2019-1020018', 'CVE-2019-1020016',
                                                        'CVE-2019-1020014', 'CVE-2019-1020011']),
    ({'search': parse_api_param('PowerPC', 'search')}, 'cve', ['CVE-2019-1020018']),
    ({'search': parse_api_param('x86', 'search')}, 'cve', ['CVE-2019-1020016', 'CVE-2019-1020014', 'CVE-2019-1020011']),
    ({'search': parse_api_param('-x86', 'search')}, 'cve', ['CVE-2019-1020018', 'CVE-2019-1020019']),
    ({'filters': {'architecture': 'x86'}}, 'cve', ['CVE-2019-1020016', 'CVE-2019-1020014', 'CVE-2019-1020011']),
    ({'filters': {'architecture': 'PowerPC'}}, 'cve', ['CVE-2019-1020018']),
    ({'filters': {'name': 'Ash-aio'}}, 'cve', ['CVE-2019-1020016']),
    ({'filters': {'version': '0.1.0'}}, 'cve', ['CVE-2019-1020014', 'CVE-2019-1020019']),
    ({'filters': {'version': '0.1.0', 'architecture': 'ARM'}}, 'cve', ['CVE-2019-1020019']),
    ({'filters': {'cve': 'CVE-2019-1020016'}}, 'cve', ['CVE-2019-1020016']),
    ({'filters': {'cve': 'CVE-2019-1020016', 'architecture': 'ARM'}}, 'cve', []),
    ({'filters': {'status': 'OBSOLETE'}}, 'cve', ['CVE-2019-1020016', 'CVE-2019-1020014']),
    ({'filters': {'status': 'VALID'}}, 'cve', ['CVE-2019-1020018', 'CVE-2019-1020019']),
    ({'filters': {'status': 'PENDING'}}, 'cve', ['CVE-2019-1020011']),
    ({'filters': {'type': 'OS'}}, 'cve', ['CVE-2019-1020016', 'CVE-2019-1020018', 'CVE-2019-1020019']),
    ({'filters': {'type': 'PACKAGE'}}, 'cve', ['CVE-2019-1020014', 'CVE-2019-1020011']),
    ({'q': 'name=Ash-aio;version>1.5'}, 'cve', ['CVE-2019-1020016']),
    ({'q': 'name=Ash-aio;version>2.5'}, 'cve', []),
    ({'q': 'architecture=ARM,architecture=PowerPC'}, 'cve', ['CVE-2019-1020018', 'CVE-2019-1020019']),
    ({'q': '(architecture=ARM,architecture=PowerPC);version>0.5'}, 'cve', ['CVE-2019-1020018']),
    ({'q': 'external_references~inveniosoftware'}, 'cve', ['CVE-2019-1020019']),
    ({'q': 'condition!=Package unfixed'}, 'cve', []),
    ({'q': 'published>2019-07-28;updated<2019-08-31'}, 'cve', ['CVE-2019-1020016', 'CVE-2019-1020019']),
    ({'q': 'title~docker-credential-helpers before 0.6.3'}, 'cve', ['CVE-2019-1020014']),
    ({'select': ['architecture'], 'distinct': False}, 'architecture', ['x86', 'x86', 'PowerPC', 'ARM', 'x86']),
    ({'select': ['architecture'], 'distinct': True}, 'architecture', ['x86', 'PowerPC', 'ARM']),
])
@patch('wazuh.core.utils.path.exists', return_value=True)
@patch('wazuh.core.wdb.WazuhDBConnection._send', side_effect=send_msg_to_wdb)
@patch('socket.socket.connect')
def test_get_agent_cve(socket_mock, send_mock, exists_mock, params, field_name, expected_items):
    """Check if expected items are returned when using filters on get_agent_cve()
    Parameters
    ----------
    params : dict
        Parameters to be used in the tested function.
    field_name : str
        Result's field to be checked.
    expected_items : list
        Items which should be returned in the response.
    """
    result = get_agent_cve(agent_list=['001'], **params).render()
    if expected_items:
        for idx, expected_value in enumerate(expected_items):
            assert result['data']['affected_items'][idx][field_name] == expected_value
    else:
        assert result['data']['affected_items'] == []


@pytest.mark.parametrize('params, expected_fields', [
    ({'select': ['cve']}, {'cve'}),
    ({'select': ['cve', 'name', 'architecture']}, {'cve', 'name', 'architecture'}),
    ({'select': ['version', 'name']}, {'version', 'name'}),
])
@patch('wazuh.core.utils.path.exists', return_value=True)
@patch('wazuh.core.wdb.WazuhDBConnection._send', side_effect=send_msg_to_wdb)
@patch('socket.socket.connect')
def test_get_agent_cve_select(socket_mock, send_mock, exists_mock, params, expected_fields):
    """Check if expected fields are returned when using select in get_agent_cve()"""
    result = get_agent_cve(agent_list=['001'], **params).render()
    for item in result['data']['affected_items']:
        assert expected_fields.symmetric_difference(
            item.keys()) == set(), '"select" param did not return expected fields.'


@patch('wazuh.core.utils.path.exists', return_value=True)
@patch('wazuh.core.wdb.WazuhDBConnection._send', side_effect=send_msg_to_wdb)
@patch('socket.socket.connect')
def test_vulnerability_get_inventory_summary(socket_mock, send_mock, exists_mock):
    """Check if `get_inventory_summary` function returns the expected data placed in the testing database."""
    agent_id = '001'
    field = 'severity'
    limit = 1

    with patch('wazuh.vulnerability.WazuhDBQueryGroupByVulnerability', side_effect=MagicMock()) as wdbqgroup_mock:
        get_inventory_summary(agent_list=[agent_id], field=field, limit=limit)
        # Check that static parameters are set
        wdbqgroup_mock.assert_called_once_with(**{'agent_id': agent_id, 'limit': limit, 'select': [field],
                                                  'sort': {'fields': ['count'], 'order': 'desc'},
                                                  'filter_fields': [field]})

    # Check that result is sorted by count values
    result = get_inventory_summary(agent_list=[agent_id], field=field, limit=limit)
    assert result['data'][field] == {'High': 2}, f'Expected "High" to be the severity with the most entries based on ' \
                                                 'our testing database'


@pytest.mark.parametrize('socket_response, failed', [
    (b'ok {"message": "ack", "error": 0}', False),
    (b'err {"message": "already requested", "error": 1}', True),
    (b'err {"message": "any other error", "error": 2}', True)
])
@patch('wazuh.vulnerability.WazuhSocket.send')
@patch('socket.socket.connect')
@patch('wazuh.core.common.WMODULES_SOCKET', new=os.path.join('var', 'ossec', 'queue', 'sockets', 'wmodules'))
@patch('wazuh.vulnerability.node_id', new='test_node')
def test_run_vulnerability_scan(connect_mock, send_mock, socket_response, failed):
    """Check if the `run_vulnerability_scan` function works properly."""
    with patch('wazuh.vulnerability.WazuhSocket.receive', return_value=socket_response) as receive_mock:
        result = run_vulnerability_scan()

        connect_mock.assert_called_once_with(os.path.join('var', 'ossec', 'queue', 'sockets', 'wmodules'))
        send_mock.assert_called_once_with('query vulnerability-detector run_now'.encode())
        receive_mock.assert_called_once()
        assert isinstance(result, AffectedItemsWazuhResult)
        data = result.render()['data']
        assert data['total_affected_items'] == (0 if failed else 1)
        assert data['total_failed_items'] == (1 if failed else 0)
        if data['failed_items']:
            socket_error = json.loads(socket_response.decode().split(" ", 1)[1])['error']
            assert data['failed_items'][0]['error']['code'] == SCAN_ON_DEMAND_EXCEPTION + socket_error


@patch('socket.socket.connect', side_effect=Exception)
@patch('wazuh.core.common.WMODULES_SOCKET', new=os.path.join('var', 'ossec', 'queue', 'sockets', 'wmodules'))
@patch('wazuh.vulnerability.node_id', new='test_node')
def test_run_vulnerability_scan_failed_item_socket(connect_mock):
    """Check if the `run_vulnerability_scan` function works properly."""
    result = run_vulnerability_scan()

    connect_mock.assert_called_once_with(os.path.join('var', 'ossec', 'queue', 'sockets', 'wmodules'))
    assert isinstance(result, AffectedItemsWazuhResult)
    assert result.render()['data']['failed_items'][0]['error']['code'] == 1121
